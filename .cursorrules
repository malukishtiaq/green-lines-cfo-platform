# Green Lines CFO Platform - Monorepo Cursor Rules

## ğŸ—ï¸ Project Overview
This is a monorepo containing the Green Lines CFO Platform with multiple applications and packages. All development must follow established patterns for consistency and maintainability.

## ğŸ“ Monorepo Structure
```
cfo_docs/
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ hq-console/          # Admin Dashboard (Next.js 14)
â”‚   â”œâ”€â”€ agent-app/           # Agent Application (Future)
â”‚   â”œâ”€â”€ customer-app/        # Customer Portal (Future)
â”‚   â””â”€â”€ api/                 # Backend API (Future)
â”œâ”€â”€ packages/
â”‚   â”œâ”€â”€ config/              # Shared configuration
â”‚   â”œâ”€â”€ database/            # Database schemas and utilities
â”‚   â”œâ”€â”€ shared-components/   # Reusable UI components
â”‚   â”œâ”€â”€ shared-types/       # TypeScript type definitions
â”‚   â””â”€â”€ shared-utils/        # Utility functions
â”œâ”€â”€ docs/                    # Documentation (ONLY centralized docs here)
â””â”€â”€ tools/                   # Development tools
```

## ğŸš« Documentation Rules (CRITICAL)
- **NO scattered MD files** in app directories
- **ONLY create docs in `docs/` folder**
- **Single progress log**: `docs/Development_Progress_Log.md`
- **NO feature-specific MD files** - creates mess
- **Update progress log** instead of creating new files

## ğŸ¯ Development Guidelines

### 1. **Application-Specific Rules**
Each app has its own `.cursorrules` file with specific patterns:
- **HQ Console**: Clean Architecture + Multi-language (Arabic RTL + English LTR)
- **Agent App**: Follow HQ Console patterns when implemented
- **Customer App**: Follow HQ Console patterns when implemented
- **API**: RESTful APIs with proper error handling

### 2. **Package Development**
When creating shared packages:
- Use TypeScript with strict typing
- Export clear interfaces and types
- Include proper documentation
- Follow semantic versioning
- Test across all consuming applications

### 3. **Monorepo Management**
- Use TurboRepo for build orchestration
- Maintain consistent dependency versions
- Use workspace protocols for internal packages
- Follow established naming conventions

## ğŸŒ Multi-Language Support (MANDATORY)

### Language Support
- **English (en)**: LTR - Default language
- **Arabic (ar)**: RTL - Full RTL support
- **URL Structure**: `/en/route` and `/ar/route`

### Translation Requirements
```typescript
// ALWAYS use translations in components
import { useTranslations } from 'next-intl';

const MyComponent = () => {
  const t = useTranslations('featureName');
  const tCommon = useTranslations('common');
  
  return <h1>{t('title')}</h1>;
};
```

### RTL/LTR Considerations
```typescript
// ALWAYS check for RTL in layout components
import { useLocale } from 'next-intl';

const MyLayout = () => {
  const locale = useLocale();
  const isRTL = locale === 'ar';
  
  return (
    <div style={{ direction: isRTL ? 'rtl' : 'ltr' }}>
      {/* Content */}
    </div>
  );
};
```

## ğŸ›ï¸ Clean Architecture (MANDATORY)

### Directory Structure
```
src/
â”œâ”€â”€ domain/                    # ğŸ¯ Domain Layer (Pure Business Logic)
â”‚   â”œâ”€â”€ entities/             # Business entities and enums
â”‚   â”œâ”€â”€ repositories/         # Repository interfaces (contracts)
â”‚   â””â”€â”€ services/            # Domain services (validation, calculations)
â”œâ”€â”€ application/              # ğŸ”§ Application Layer (Use Cases & Services)
â”‚   â”œâ”€â”€ use-cases/           # Business use cases
â”‚   â”œâ”€â”€ services/            # Application services (orchestration)
â”‚   â””â”€â”€ index.ts            # Dependency injection container
â”œâ”€â”€ infrastructure/          # ğŸ—„ï¸ Infrastructure Layer (External Concerns)
â”‚   â”œâ”€â”€ database/           # Database configuration
â”‚   â”œâ”€â”€ http/               # HTTP client (like Flutter's Dio)
â”‚   â”œâ”€â”€ repositories/       # Repository implementations
â”‚   â””â”€â”€ services/           # External services (email, payments)
â””â”€â”€ presentation/            # ğŸ¨ Presentation Layer (UI)
    â”œâ”€â”€ components/         # React components
    â”œâ”€â”€ hooks/             # Custom React hooks
    â””â”€â”€ pages/             # Next.js pages (if needed)
```

### Dependency Flow Rules
- **Inner layers** don't know about **outer layers**
- **Outer layers** depend on **inner layers**
- **Domain layer** has NO external dependencies
- Use dependency injection through factories

## ğŸŒ HTTP Client Pattern (Like Flutter's Dio)

### Centralized HTTP Client
```typescript
// Use centralized HTTP client for ALL API calls
import { httpClient } from '@/infrastructure/http/HttpClient';

// Instead of scattered axios calls
const response = await httpClient.get<Customer[]>('/customers');
const customer = await httpClient.post<Customer>('/customers', customerData);
```

### HTTP Client Features
- **Singleton Pattern**: One instance across entire app
- **Request/Response Logging**: Like Dio printing - see all API calls in console
- **Automatic Auth**: Bearer token handling
- **Error Handling**: Centralized 401 redirects
- **Easy Switching**: Change from axios to fetch/dio in one file

## ğŸ” Access Control System (MANDATORY)

### User Roles
- **Owner**: Can do everything (create users, delete users, access settings)
- **CEO**: Can see everything but can't delete users or change settings
- **Admin**: Can manage most things but not settings or user creation
- **HR**: Can manage users and profiles
- **Accountant**: Can manage payments and financial data
- **Moderator**: Can manage tasks and customers but not settings
- **Agent**: Can manage assigned tasks only
- **Customer**: Can only view their own data

### Permission Usage
```typescript
// Check permissions
const { hasPermission, canAccessPage } = useAccessControl(UserRole.ADMIN);

// Conditional rendering
<PermissionGate permission={Permission.READ_REPORTS}>
  <ReportsButton />
</PermissionGate>

// Page access
if (!canAccessPage('settings')) {
  return <AccessDenied />;
}
```

## ğŸ¨ Design System (Centralized Styling)

### Theme Configuration
```typescript
// Change entire app design from one file
// src/design-system/theme.ts
export const themeConfig = {
  colors: {
    primary: '#1890ff', // Change this to update entire app
    secondary: '#52c41a',
  },
  typography: {
    fontFamily: {
      primary: 'Inter, sans-serif', // Change font here
    },
  },
};
```

### Usage Patterns
```typescript
// Method 1: Theme Configuration
const { themeConfig } = useTheme();
<div style={{ backgroundColor: themeConfig.colors.primary }}>

// Method 2: CSS Variables
<div className="bg-primary text-white">

// Method 3: Utility Classes
<div className="p-lg m-md border-radius-md shadow-md">
```

## ğŸ”§ Service Architecture

### Service Types
- **Domain Services**: Pure business logic (validation, calculations)
- **Application Services**: Use case orchestration (transactions, workflows)
- **Infrastructure Services**: External integrations (email, payments, files)

### Service Usage
```typescript
// Get services through factory
const emailService = ServiceFactory.getEmailService();
const validationService = ServiceFactory.getValidationService();

// Use in use cases
if (!validationService.isValidEmail(email)) {
  throw new Error('Invalid email');
}
await emailService.sendWelcomeEmail(email, data);
```

## ğŸ“ Translation Requirements (MANDATORY)

### Always Add Translations
When creating new features, ALWAYS add translations to both language files:

```json
// messages/en.json
{
  "newEntity": {
    "title": "New Entity Management",
    "name": "Name",
    "description": "Description",
    "create": "Create New Entity",
    "edit": "Edit Entity",
    "delete": "Delete Entity"
  }
}
```

```json
// messages/ar.json
{
  "newEntity": {
    "title": "Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙƒÙŠØ§Ù† Ø§Ù„Ø¬Ø¯ÙŠØ¯",
    "name": "Ø§Ù„Ø§Ø³Ù…",
    "description": "Ø§Ù„ÙˆØµÙ",
    "create": "Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙŠØ§Ù† Ø¬Ø¯ÙŠØ¯",
    "edit": "ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ÙƒÙŠØ§Ù†",
    "delete": "Ø­Ø°Ù Ø§Ù„ÙƒÙŠØ§Ù†"
  }
}
```

## ğŸ”§ Technical Standards

### TypeScript
- Use strict TypeScript across all packages
- Define proper interfaces and types
- Avoid `any` type usage
- Use proper error handling

### Code Quality
- Follow ESLint and Prettier configurations
- Use meaningful variable and function names
- Write self-documenting code
- Include proper comments for complex logic

### Error Handling
```typescript
// Always handle errors properly
try {
  const result = await useCase.execute(data);
  return result;
} catch (error) {
  if (error instanceof Error) {
    setError(error.message);
  } else {
    setError('An unexpected error occurred');
  }
  throw error;
}
```

## ğŸ“‹ Code Review Checklist

Before submitting any code, ensure:

- [ ] **Architecture**: Follows clean architecture principles
- [ ] **Multi-language**: All text is translated (en.json + ar.json)
- [ ] **RTL Support**: Layout works in both LTR and RTL
- [ ] **TypeScript**: Proper typing, no `any` usage
- [ ] **Error Handling**: Proper try-catch blocks
- [ ] **Loading States**: User feedback during async operations
- [ ] **Responsive**: Works on all screen sizes
- [ ] **Accessibility**: Proper ARIA labels and semantic HTML
- [ ] **Performance**: Optimized re-renders and API calls
- [ ] **HTTP Client**: Uses centralized HTTP client
- [ ] **Access Control**: Proper permission checks
- [ ] **Design System**: Uses centralized styling
- [ ] **Services**: Uses service architecture
- [ ] **Documentation**: Updated progress log only

## ğŸ¯ File Naming Conventions

### Applications
- **Components**: PascalCase (`NewEntityComponent.tsx`)
- **Hooks**: camelCase starting with `use` (`useNewEntity.ts`)
- **Use Cases**: PascalCase ending with `UseCase` (`CreateNewEntityUseCase.ts`)
- **Services**: PascalCase ending with `Service` (`NewEntityValidationService.ts`)
- **Repositories**: PascalCase ending with `Repository` (`PrismaNewEntityRepository.ts`)
- **Entities**: PascalCase (`NewEntity.ts`)
- **Types**: PascalCase (`NewEntityStatus.ts`)

### Packages
- **Config**: kebab-case (`eslint-config.ts`)
- **Components**: PascalCase (`Button.tsx`)
- **Types**: PascalCase (`ApiTypes.ts`)
- **Utils**: camelCase (`formatDate.ts`)

## ğŸ”„ Git Workflow

1. **Feature Branch**: Create feature branch from `main`
2. **Clean Architecture**: Implement following the 4-layer pattern
3. **Translations**: Add translations to both language files
4. **RTL Testing**: Test Arabic layout
5. **Code Review**: Ensure all checklist items are met
6. **Merge**: Merge to `main` after approval

## ğŸš« Common Mistakes to Avoid

1. **Don't skip translations** - Every user-facing text must be translated
2. **Don't ignore RTL** - Always test Arabic layout
3. **Don't bypass clean architecture** - Follow the layer dependencies
4. **Don't use `any` type** - Use proper TypeScript typing
5. **Don't forget error handling** - Always handle async operations
6. **Don't skip loading states** - Users need feedback
7. **Don't ignore accessibility** - Use semantic HTML and ARIA labels
8. **Don't create scattered MD files** - Only use centralized docs
9. **Don't use direct axios/fetch** - Use centralized HTTP client
10. **Don't hardcode permissions** - Use access control system
11. **Don't hardcode styles** - Use design system
12. **Don't skip services** - Use service architecture

## ğŸ‰ Success Criteria

A feature is complete when:
- âœ… Follows clean architecture principles
- âœ… Supports both English and Arabic
- âœ… Works in both LTR and RTL layouts
- âœ… Has proper TypeScript typing
- âœ… Includes error handling and loading states
- âœ… Is responsive and accessible
- âœ… Uses centralized HTTP client
- âœ… Implements proper access control
- âœ… Uses design system for styling
- âœ… Uses service architecture
- âœ… Has been tested in both languages
- âœ… Follows established patterns
- âœ… Progress log is updated (NO new MD files)

## ğŸ“š Resources

- **Development Progress**: `docs/Development_Progress_Log.md`
- **Project Guide**: `docs/Project_Guide.md`
- **Phase Implementation**: `docs/Phase_2_Implementation.md`

Remember: Consistency across the entire monorepo is key! Every new feature should feel like it belongs in the same ecosystem.
