# HQ Console - Application-Specific Cursor Rules

## 🏗️ Project Overview
This is the HQ Console (Admin Dashboard) - a Next.js 14 application with Clean Architecture, Multi-language support (Arabic RTL + English LTR), centralized HTTP client, access control system, design system, and service architecture. All development must follow these established patterns.

## 🚫 Documentation Rules (CRITICAL)
- **NO MD files in this directory** - creates mess
- **ONLY update `docs/Development_Progress_Log.md`** in root
- **NO feature-specific documentation files**
- **NO scattered README files**

## 🌐 HTTP Client Pattern (Like Flutter's Dio)

### Centralized HTTP Client Usage
```typescript
// Use centralized HTTP client for ALL API calls
import { httpClient } from '@/infrastructure/http/HttpClient';

// Instead of scattered axios calls
const response = await httpClient.get<Customer[]>('/customers');
const customer = await httpClient.post<Customer>('/customers', customerData);
```

### HTTP Client Features
- **Singleton Pattern**: One instance across entire app
- **Request/Response Logging**: Like Dio printing - see all API calls in console
- **Automatic Auth**: Bearer token handling
- **Error Handling**: Centralized 401 redirects
- **Easy Switching**: Change from axios to fetch/dio in one file

## 🔐 Access Control System (MANDATORY)

### User Roles
- **Owner**: Can do everything (create users, delete users, access settings)
- **CEO**: Can see everything but can't delete users or change settings
- **Admin**: Can manage most things but not settings or user creation
- **HR**: Can manage users and profiles
- **Accountant**: Can manage payments and financial data
- **Moderator**: Can manage tasks and customers but not settings
- **Agent**: Can manage assigned tasks only
- **Customer**: Can only view their own data

### Permission Usage
```typescript
// Check permissions
const { hasPermission, canAccessPage } = useAccessControl(UserRole.ADMIN);

// Conditional rendering
<PermissionGate permission={Permission.READ_REPORTS}>
  <ReportsButton />
</PermissionGate>

// Page access
if (!canAccessPage('settings')) {
  return <AccessDenied />;
}
```

## 🎨 Design System (Centralized Styling)

### Theme Configuration
```typescript
// Change entire app design from one file
// src/design-system/theme.ts
export const themeConfig = {
  colors: {
    primary: '#1890ff', // Change this to update entire app
    secondary: '#52c41a',
  },
  typography: {
    fontFamily: {
      primary: 'Inter, sans-serif', // Change font here
    },
  },
};
```

### Usage Patterns
```typescript
// Method 1: Theme Configuration
const { themeConfig } = useTheme();
<div style={{ backgroundColor: themeConfig.colors.primary }}>

// Method 2: CSS Variables
<div className="bg-primary text-white">

// Method 3: Utility Classes
<div className="p-lg m-md border-radius-md shadow-md">
```

## 🔧 Service Architecture

### Service Types
- **Domain Services**: Pure business logic (validation, calculations)
- **Application Services**: Use case orchestration (transactions, workflows)
- **Infrastructure Services**: External integrations (email, payments, files)

### Service Usage
```typescript
// Get services through factory
const emailService = ServiceFactory.getEmailService();
const validationService = ServiceFactory.getValidationService();

// Use in use cases
if (!validationService.isValidEmail(email)) {
  throw new Error('Invalid email');
}
await emailService.sendWelcomeEmail(email, data);
```

## 🌍 Multi-Language Support (MANDATORY)

### Language Support
- **English (en)**: LTR - Default language
- **Arabic (ar)**: RTL - Full RTL support
- **URL Structure**: `/en/route` and `/ar/route`

### Translation Requirements
```typescript
// ALWAYS use translations in components
import { useTranslations } from 'next-intl';

const MyComponent = () => {
  const t = useTranslations('featureName'); // Use specific namespace
  const tCommon = useTranslations('common'); // For common terms
  
  return <h1>{t('title')}</h1>;
};
```

### Translation File Structure
```json
// messages/en.json and messages/ar.json
{
  "featureName": {
    "title": "Feature Title",
    "description": "Feature Description",
    "actions": {
      "save": "Save",
      "cancel": "Cancel"
    }
  }
}
```

### RTL/LTR Considerations
```typescript
// ALWAYS check for RTL in layout components
import { useLocale } from 'next-intl';

const MyLayout = () => {
  const locale = useLocale();
  const isRTL = locale === 'ar';
  
  return (
    <div style={{ direction: isRTL ? 'rtl' : 'ltr' }}>
      {/* Content */}
    </div>
  );
};
```

## 🏛️ Clean Architecture (MANDATORY)

### Directory Structure
```
src/
├── domain/                    # 🎯 Domain Layer (Pure Business Logic)
│   ├── entities/             # Business entities and enums
│   └── repositories/         # Repository interfaces (contracts)
├── application/              # 🔧 Application Layer (Use Cases & Services)
│   ├── use-cases/           # Business use cases
│   ├── services/            # Cross-cutting services
│   └── index.ts            # Dependency injection container
├── infrastructure/          # 🗄️ Infrastructure Layer (External Concerns)
│   ├── database/           # Database configuration
│   └── repositories/       # Repository implementations
└── presentation/            # 🎨 Presentation Layer (UI)
    ├── components/         # React components
    ├── hooks/             # Custom React hooks
    └── pages/             # Next.js pages (if needed)
```

### Dependency Flow Rules
- **Inner layers** don't know about **outer layers**
- **Outer layers** depend on **inner layers**
- **Domain layer** has NO external dependencies
- Use dependency injection through factories

### Creating New Features

#### 1. Domain Layer First
```typescript
// src/domain/entities/index.ts
export interface NewEntity {
  id: string;
  name: string;
  // ... other properties
}

export enum NewEntityStatus {
  ACTIVE = 'ACTIVE',
  INACTIVE = 'INACTIVE',
}
```

```typescript
// src/domain/repositories/index.ts
export interface INewEntityRepository {
  findById(id: string): Promise<NewEntity | null>;
  findAll(): Promise<NewEntity[]>;
  create(entity: Omit<NewEntity, 'id' | 'createdAt' | 'updatedAt'>): Promise<NewEntity>;
  update(id: string, entity: Partial<NewEntity>): Promise<NewEntity>;
  delete(id: string): Promise<void>;
}
```

#### 2. Application Layer
```typescript
// src/application/use-cases/index.ts
export class CreateNewEntityUseCase {
  constructor(private repository: INewEntityRepository) {}
  
  async execute(data: NewEntityData): Promise<NewEntity> {
    // Business logic validation
    if (!data.name) {
      throw new Error('Name is required');
    }
    
    return this.repository.create(data);
  }
}
```

```typescript
// src/application/services/index.ts
export class NewEntityValidationService {
  validateEntityData(data: Partial<NewEntity>): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    if (!data.name || data.name.trim().length === 0) {
      errors.push('Name is required');
    }
    
    return { isValid: errors.length === 0, errors };
  }
}
```

#### 3. Infrastructure Layer
```typescript
// src/infrastructure/repositories/index.ts
export class PrismaNewEntityRepository implements INewEntityRepository {
  private prisma = PrismaService.getInstance();

  async findById(id: string): Promise<NewEntity | null> {
    const entity = await this.prisma.newEntity.findUnique({ where: { id } });
    return entity as NewEntity | null;
  }

  async create(entityData: Omit<NewEntity, 'id' | 'createdAt' | 'updatedAt'>): Promise<NewEntity> {
    const entity = await this.prisma.newEntity.create({ 
      data: {
        name: entityData.name,
        // ... other fields
      }
    });
    return entity as NewEntity;
  }
  
  // ... other methods
}
```

#### 4. Presentation Layer
```typescript
// src/presentation/hooks/index.ts
export const useNewEntity = () => {
  const [entities, setEntities] = useState<NewEntity[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchEntities = async () => {
      try {
        setLoading(true);
        const useCase = new GetNewEntitiesUseCase(RepositoryFactory.getNewEntityRepository());
        const data = await useCase.execute();
        setEntities(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to fetch entities');
      } finally {
        setLoading(false);
      }
    };

    fetchEntities();
  }, []);

  const createEntity = async (entityData: Omit<NewEntity, 'id' | 'createdAt' | 'updatedAt'>) => {
    try {
      const useCase = new CreateNewEntityUseCase(RepositoryFactory.getNewEntityRepository());
      const newEntity = await useCase.execute(entityData);
      setEntities(prev => [...prev, newEntity]);
      return newEntity;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create entity');
      throw err;
    }
  };

  return { entities, loading, error, createEntity };
};
```

```typescript
// src/presentation/components/NewEntityComponent.tsx
'use client';

import React from 'react';
import { Card, Button, Table, Space, Typography } from 'antd';
import { useNewEntity } from '../hooks';
import { useTranslations } from 'next-intl';

const { Title } = Typography;

const NewEntityComponent: React.FC = () => {
  const { entities, loading, error, createEntity } = useNewEntity();
  const t = useTranslations('newEntity');
  const tCommon = useTranslations('common');

  const columns = [
    {
      title: t('name'),
      dataIndex: 'name',
      key: 'name',
    },
    {
      title: tCommon('actions'),
      key: 'actions',
      render: () => (
        <Space>
          <Button size="small">{tCommon('edit')}</Button>
          <Button size="small" danger>{tCommon('delete')}</Button>
        </Space>
      ),
    },
  ];

  return (
    <Card title={t('title')}>
      <Table
        columns={columns}
        dataSource={entities}
        loading={loading}
        rowKey="id"
      />
    </Card>
  );
};

export default NewEntityComponent;
```

## 📝 Translation Requirements

### Always Add Translations
When creating new features, ALWAYS add translations to both language files:

```json
// messages/en.json
{
  "newEntity": {
    "title": "New Entity Management",
    "name": "Name",
    "description": "Description",
    "create": "Create New Entity",
    "edit": "Edit Entity",
    "delete": "Delete Entity"
  }
}
```

```json
// messages/ar.json
{
  "newEntity": {
    "title": "إدارة الكيان الجديد",
    "name": "الاسم",
    "description": "الوصف",
    "create": "إنشاء كيان جديد",
    "edit": "تعديل الكيان",
    "delete": "حذف الكيان"
  }
}
```

## 🎨 UI/UX Guidelines

### Ant Design Components
- Use Ant Design components consistently
- Follow Ant Design's design system
- Ensure RTL compatibility for all components

### RTL/LTR Styling
```css
/* Always consider RTL in custom styles */
.my-component {
  margin-left: 16px; /* LTR */
}

[dir="rtl"] .my-component {
  margin-left: 0;
  margin-right: 16px; /* RTL */
}
```

### Responsive Design
- Use Ant Design's responsive grid system
- Test on mobile, tablet, and desktop
- Ensure RTL layout works on all screen sizes

## 🔧 Technical Requirements

### TypeScript
- Use strict TypeScript
- Define proper interfaces and types
- Avoid `any` type usage
- Use proper error handling

### Error Handling
```typescript
// Always handle errors properly
try {
  const result = await useCase.execute(data);
  return result;
} catch (error) {
  if (error instanceof Error) {
    setError(error.message);
  } else {
    setError('An unexpected error occurred');
  }
  throw error;
}
```

### Performance
- Use React.memo for expensive components
- Implement proper loading states
- Use proper dependency arrays in useEffect
- Optimize re-renders

## 📋 Code Review Checklist

Before submitting any code, ensure:

- [ ] **Clean Architecture**: Follows the 4-layer architecture
- [ ] **Multi-language**: All text is translated (en.json + ar.json)
- [ ] **RTL Support**: Layout works in both LTR and RTL
- [ ] **TypeScript**: Proper typing, no `any` usage
- [ ] **Error Handling**: Proper try-catch blocks
- [ ] **Loading States**: User feedback during async operations
- [ ] **Responsive**: Works on all screen sizes
- [ ] **Accessibility**: Proper ARIA labels and semantic HTML
- [ ] **Performance**: Optimized re-renders and API calls
- [ ] **Testing**: Consider testability in design

## 🚫 Common Mistakes to Avoid

1. **Don't skip translations** - Every user-facing text must be translated
2. **Don't ignore RTL** - Always test Arabic layout
3. **Don't bypass clean architecture** - Follow the layer dependencies
4. **Don't use `any` type** - Use proper TypeScript typing
5. **Don't forget error handling** - Always handle async operations
6. **Don't skip loading states** - Users need feedback
7. **Don't ignore accessibility** - Use semantic HTML and ARIA labels

## 🎯 File Naming Conventions

- **Components**: PascalCase (`NewEntityComponent.tsx`)
- **Hooks**: camelCase starting with `use` (`useNewEntity.ts`)
- **Use Cases**: PascalCase ending with `UseCase` (`CreateNewEntityUseCase.ts`)
- **Services**: PascalCase ending with `Service` (`NewEntityValidationService.ts`)
- **Repositories**: PascalCase ending with `Repository` (`PrismaNewEntityRepository.ts`)
- **Entities**: PascalCase (`NewEntity.ts`)
- **Types**: PascalCase (`NewEntityStatus.ts`)

## 🔄 Git Workflow

1. **Feature Branch**: Create feature branch from `main`
2. **Clean Architecture**: Implement following the 4-layer pattern
3. **Translations**: Add translations to both language files
4. **RTL Testing**: Test Arabic layout
5. **Code Review**: Ensure all checklist items are met
6. **Merge**: Merge to `main` after approval

## 📚 Documentation

- Document all new features in the appropriate guide
- Update `CLEAN_ARCHITECTURE.md` if architecture changes
- Update `MULTI_LANGUAGE_GUIDE.md` if i18n patterns change
- Add JSDoc comments to complex functions

## 🎉 Success Criteria

A feature is complete when:
- ✅ Follows clean architecture principles
- ✅ Supports both English and Arabic
- ✅ Works in both LTR and RTL layouts
- ✅ Has proper TypeScript typing
- ✅ Includes error handling and loading states
- ✅ Is responsive and accessible
- ✅ Has been tested in both languages
- ✅ Follows established patterns

Remember: Consistency is key! Every new feature should feel like it belongs in the same application.
